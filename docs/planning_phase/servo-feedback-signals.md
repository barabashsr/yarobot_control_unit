# Servo Feedback Signals - Z-Signal and InPos Processing

## Overview
This document describes the processing of servo feedback signals (Z-signal/index pulse and InPos/position complete) for the YaRobot navigation axes (X, Y, Z, A, B). These signals are optional but recommended for accurate positioning and motion sequencing.

## Signal Availability
Not all servo drivers provide these signals:
- **Z-signal**: Requires encoder with index channel
- **InPos**: Requires servo driver with position complete output
- Both can be individually enabled/disabled per axis via configuration

## Core Concepts

### 1. Z-Signal (Index Pulse)
The Z-signal is a once-per-revolution index pulse generated by the servo encoder that provides absolute position reference.

#### Purpose
- **Position Verification**: Confirms counted position matches physical position
- **Drift Correction**: Eliminates cumulative errors from missed pulses
- **Absolute Reference**: Provides known position point for calibration

#### Key Characteristics
- Occurs once per motor revolution
- Rising edge triggered
- Pulse width can be gated (90-360 electrical degrees)
- Hardware interrupt required for accurate capture

### 2. InPos Signal (Position Complete)
The InPos signal indicates when the servo has reached and settled at the commanded position within specified tolerance.

#### Purpose
- **Motion Confirmation**: Verifies axis has reached target before next operation
- **Sequencing Control**: Enables safe multi-axis coordinated motion
- **Safety Interlock**: Prevents premature movement of dependent axes

#### Key Characteristics
- Based on position deviation counter in servo driver
- Activates when: |position_error| < tolerance_window
- Requires settling time (typically 50-200ms)
- Remains active while position maintained

## Implementation Architecture

### Hardware Connections
```
Servo Feedback via MCP23017 #3 (0x22):
├── GPA0: X_POS_COMPLETE (InPos)
├── GPA1: Y_POS_COMPLETE (InPos)
├── GPA2: Z_POS_COMPLETE (InPos)
├── GPA3: A_POS_COMPLETE (InPos)
├── GPA4: B_POS_COMPLETE (InPos)
└── GPA5-7: Reserved

Z-Signals via dedicated GPIO (hardware interrupts):
├── GPIO_X_Z_SIGNAL: X axis index pulse
├── GPIO_Y_Z_SIGNAL: Y axis index pulse
├── GPIO_Z_Z_SIGNAL: Z axis index pulse
├── GPIO_A_Z_SIGNAL: A axis index pulse
└── GPIO_B_Z_SIGNAL: B axis index pulse
```

### Signal Processing Flow

#### Z-Signal Processing
```c
typedef struct {
    int32_t expected_count;      // Expected encoder count at index
    int32_t actual_count;        // Actual count when index occurred
    int32_t tolerance;           // Acceptable deviation (±counts)
    bool calibration_valid;      // Calibration status
    TickType_t last_z_time;      // Timestamp of last Z-pulse
} z_signal_state_t;

// Interrupt Service Routine (ISR)
void IRAM_ATTR z_signal_isr(void* arg) {
    axis_t* axis = (axis_t*)arg;
    
    // Capture current encoder count
    axis->z_state.actual_count = read_encoder_count(axis);
    
    // Calculate deviation
    int32_t deviation = axis->z_state.actual_count - 
                       axis->z_state.expected_count;
    
    // Check if within tolerance
    if (abs(deviation) > axis->z_state.tolerance) {
        // Queue recalibration event
        xQueueSendFromISR(z_signal_queue, &axis->id, NULL);
    }
    
    // Update expected count for next revolution
    axis->z_state.expected_count += axis->counts_per_rev;
    axis->z_state.last_z_time = xTaskGetTickCountFromISR();
}
```

#### InPos Signal Processing
```c
typedef struct {
    bool current_state;          // Current InPos state
    bool previous_state;         // Previous InPos state
    TickType_t state_change_time; // When state last changed
    uint32_t settling_time_ms;   // Required settling time
    bool position_confirmed;     // Position reached and settled
} inpos_state_t;

// Polled in I2C task at 100Hz
void process_inpos_signals(void) {
    uint8_t inpos_states = read_mcp23017(MCP_SERVO_FB, GPIOA);
    
    for (int axis = 0; axis < 5; axis++) {
        bool new_state = (inpos_states & (1 << axis)) != 0;
        inpos_state_t* state = &axis_inpos[axis];
        
        if (new_state != state->previous_state) {
            state->previous_state = new_state;
            state->state_change_time = xTaskGetTickCount();
            state->position_confirmed = false;
        }
        
        // Check settling time
        if (new_state && !state->position_confirmed) {
            TickType_t elapsed = xTaskGetTickCount() - 
                               state->state_change_time;
            
            if (elapsed >= pdMS_TO_TICKS(state->settling_time_ms)) {
                state->position_confirmed = true;
                
                // Generate position complete event
                motion_event_t event = {
                    .type = EVENT_POSITION_COMPLETE,
                    .axis = axis,
                    .timestamp = xTaskGetTickCount()
                };
                xQueueSend(event_queue, &event, 0);
            }
        }
    }
}
```

## Configuration Parameters

### Per-Axis Configuration
```c
typedef struct {
    // Z-Signal parameters
    bool z_signal_enabled;          // Enable Z-signal checking
    gpio_num_t z_signal_pin;        // GPIO pin assignment
    int32_t z_signal_tolerance;     // Default: ±5 counts
    int32_t counts_per_revolution;  // Encoder specific
    bool z_signal_inverted;         // Signal polarity
    
    // InPos parameters  
    bool inpos_enabled;             // Enable InPos monitoring
    uint8_t inpos_pin_addr;         // I2C expander address
    uint8_t inpos_pin_bit;          // Pin bit on expander
    uint32_t inpos_settling_ms;     // Default: 100ms
    uint32_t inpos_timeout_ms;      // Default: 5000ms
    bool inpos_inverted;            // Signal polarity
    bool inpos_required;            // Block until InPos confirmed
} axis_feedback_config_t;
```

### Runtime Enable/Disable
Feedback signals can be enabled/disabled at runtime:
```c
// Disable Z-signal if encoder doesn't have index
feedback_enable_z_signal(AXIS_X, false);

// Disable InPos if servo driver doesn't provide it
feedback_enable_inpos(AXIS_Y, false);

// Check if signals are available
if (!axis_config[AXIS_X].feedback.z_signal_enabled) {
    ESP_LOGW(TAG, "X axis operating without Z-signal verification");
}
```

## Usage Guidelines

### 1. Motion Sequencing with InPos
```c
// Example: Move X axis and wait for position confirmation
void move_x_with_confirmation(int32_t target) {
    // Start movement
    servo_move_to(AXIS_X, target);
    
    // Wait for InPos confirmation
    motion_event_t event;
    TickType_t timeout = pdMS_TO_TICKS(5000); // 5s timeout
    
    if (xQueueReceive(event_queue, &event, timeout)) {
        if (event.type == EVENT_POSITION_COMPLETE && 
            event.axis == AXIS_X) {
            // Position confirmed, safe to proceed
            return;
        }
    }
    
    // Timeout - handle error
    trigger_estop("X axis position not confirmed");
}
```

### 2. Z-Signal Calibration
```c
// Handle Z-signal recalibration
void handle_z_signal_event(axis_id_t axis) {
    z_signal_state_t* state = &axis_z_state[axis];
    
    // Log deviation for diagnostics
    ESP_LOGW(TAG, "Axis %d Z-signal deviation: %d counts", 
             axis, state->actual_count - state->expected_count);
    
    // Recalibrate position
    set_encoder_count(axis, state->expected_count);
    state->calibration_valid = true;
    
    // Generate calibration event
    motion_event_t event = {
        .type = EVENT_Z_CALIBRATION,
        .axis = axis,
        .data = state->actual_count - state->expected_count
    };
    xQueueSend(event_queue, &event, 0);
}
```

## Timing Considerations

### Z-Signal Timing
- Interrupt latency: <10μs required
- Debounce window: 1-2ms 
- Minimum revolution time: 100ms (for reliable detection)

### InPos Timing  
- Polling rate: 100Hz (via I2C)
- Settling time: 50-200ms (configurable)
- Total position confirmation: movement_time + settling_time

## Error Handling

### Z-Signal Errors
1. **Missing Z-pulses**: No pulse within expected rotation time
2. **Excessive deviation**: Position error > tolerance
3. **Multiple pulses**: Noise causing false triggers

### InPos Errors
1. **Timeout**: InPos not achieved within timeout period  
2. **Position lost**: InPos deasserts after confirmation
3. **I2C failure**: Cannot read InPos states

## Integration with Motion Control

### State Machine Integration
```
IDLE -> MOVING -> SETTLING -> POSITION_CONFIRMED -> IDLE
         |           |              |
         +-> ERROR <-+<-------------+
```

### Event Generation
- `EVENT_POSITION_COMPLETE`: InPos confirmed after settling
- `EVENT_Z_CALIBRATION`: Z-signal triggered recalibration
- `EVENT_POSITION_ERROR`: Position not achieved or lost

## Testing and Validation

### Z-Signal Testing
1. Rotate axis at various speeds
2. Verify pulse detection at all speeds
3. Inject position errors and verify correction
4. Test with motor disabled (no pulses)

### InPos Testing  
1. Command moves of various distances
2. Verify InPos timing matches servo specs
3. Test with different settling times
4. Verify behavior at position limits

## Notes

- C and D axes use steppers for pick/place operations and do not require these servo feedback signals
- Z-signal GPIO assignments must support hardware interrupts
- InPos signals are read via I2C to conserve GPIO pins
- Both signals are optional but recommended for precision applications